(comment 
  (for [a (range 1 100)
        b (range 1 100)] [a, b])
  (when (seq xs)
    (let [[a, b] (first xs)
          c (Math/sqrt (+ (Math/pow (int a) 2)
                          (Math/pow (int b) 2)))]
      (if (not (= 12 (+ a b c)))
        (recur (next xs))
        (list a b c)))))
(comment
  (into []  ;
        (map (fn[loc2] [location loc2])
             (apply concat 
                    (remove true? 
                            (for [op1  [+ -] op2 [+ -]]  ;; to generate 4 diagonals
                              (map (fn[loc]
                                     (println "some- loc is" loc)
                                     (cond
                                       (off-board? loc))
                                     nil 
                                     (occupied-by-enemy? board loc color)
                                     loc
                                     (occupied? board loc) 
                                     true
                                     ))
                              (for [z (drop 1(range))]  [(op1 x z) (op2 y z)])
                              )
                            )
                    ))))

